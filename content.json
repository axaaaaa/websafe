{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Test Vulnerability的终极之道","text":"攻击终极之道：输入数据 不管任何形式的网络攻击渗透，都必须向目标输入数据，而目标必须有接口。这是不变的法则，所有的形式都是围绕此项来进行，可谓大道至简。 Web Pages的输入口输入框： &lt;form&gt; &lt;input&gt; prompt() HTTP请求包：URL链接：GET参数 POST参数 输入口产生漏洞的信息泄露 未过滤，过滤不全 未限制入口次数 审核HTML和JS源码F12开发者工具 攻击者输入的数据 SQL语句 系统命令 JavaScript代码 PHP代码 JAVA代码 攻击者的目的与行为窃取 篡改","link":"/2022/06/27/Test%20Web%20Vulnerability/"},{"title":"Fiddler抓包iOS","text":"官方文档https://docs.telerik.com/fiddler/Configure-Fiddler/Tasks/ConfigureForiOS 配置FiddlerTools（工具）&gt; Fiddler Options（选项）&gt;HTTPS&gt;禁用捕获 HTTPS连接 关闭Fiddler，下载并安装： https://telerik-fiddler.s3.amazonaws.com/fiddler/addons/fiddlercertmaker.exe","link":"/2022/06/28/Fiddler/Fiddler%E6%8A%93%E5%8C%85IOS/"},{"title":"梦想与前行，信息安全的学习与思考。","text":"信息安全难点信息安全的难点在于它的广度太广，需要学习很多知识，在挖掘某项漏洞时，你需要了解它，知道在如何运作的，如果是二进制漏洞挖掘，你需要懂得，计算机系统知识，编程，系统原理，漏洞的类型，逆向工程，内核编程等一系列知识，涉及的东西非常广，如果你那方面欠缺，那就会搞不来，需要花大量的时间去学习。当你不理解一件事时，一定有一些信息你没掌握。 学习的坑找对教程，找对老师很重要。垃圾教程，垃圾老师，可以把一个人毁掉。没人能帮你，没人能教会你，只有你自己教会自己。只有你自己记忆。当遇到问题时，Google 和 YouTube 是你最好的朋友。 信息知识的源头关注信息知识的源头，而不是二手知识，原文档是最好的资料。比如很多计算机知识的源自国外，那就要去源头去学习。 一个人不可能什么都知道。在这种情况下，必须学习如何，以及需要的信息 信息安全领域是巨大的。任何一个人都不可能学到所有东西。举下面的例子： 你想成为一名程序员，有200多种不同的编程语言可以用来创建可以通过调试或逆向工程破解的应用程序。如果我们在100小时内学会了每一种编程语言，将花费20，000小时或2，500天（每天8小时），换句话说，将近七年的时间来学习所有这些编程语言。因此，我们花了七年时间学习所有这些语言，从未尝试调试或逆向工程创建的程序。再花七年时间学习调试和逆向工程。 只有通过大量的实践，才能成为一名优秀的渗透测试人员。 execute 执行者 边看、边操作、边记录 跳出框框思考：黑客的思维方式，在盒子外面。在渗透测试期间，必须关注许多不同的技术。没有目标，将迷失方向。我们已经知道什么？我们不知道什么？失败，是学习的一部分 漏洞的逻辑在正常的业务1，2，3，4中，黑客直接跳到最终结果，跳过中间流程。 阅读正常的逻辑代码，把整个代码逻辑流程弄清楚，然后发现那些输入点能被用户控制，然后加入自己的思想。 提高的能力1.提高编码水平 2.提高阅读编码水平 3.熟悉各种原理机制 被动学习通过观看一些演示，我们不会学到更多，看了视频虽然明白，但是操作起来有时还没有明白。这是因为在看视频中还没有学会。 主动学习（重要）当练习（重要）时，学习经验会增长到50%75%当在驾驶学校学习理论时。学到了很多关于汽车和交通规则的知识。告诉了你怎么挂挡，加油门等，虽然你知道了这些，但当你第一次进入汽车，就会意识到所有这些知识仍然没有教会我们如何驾驶汽车。 思考当出现错误或者问题时，请问自己，这个问题是什么原因，是哪里产生的。如何解决。 工具要想扬帆于二进制海洋，除了水手般坚定的意志外，还需要有能够乘风破浪的坚船利器，定位精准的陀螺码表。没有工具的hacker如同没有枪的战士，子曰：工欲善其事，必先利其器。 笔记关于笔记，我觉得可以直接抄别人的或者搜索别人的笔记，因为记笔记实在是花太多时间，有太多东西需要学习，我觉得，你只需要弄懂了目标知识，笔记尽量下载别人的，或者复制粘贴，当忘记的时候，直接翻看别人的笔记。 最后，切勿制造重复的轮子。 提取规律当学习一件事物的时候，一定是你自己找到规律。并记住 持续的走路当不能给自己确认的时候，我们会从别人那里寻找它。如果其他人没有与我们一起走这条路，任何人都无法确认。为了清楚起见，让我们回到山区的例子。 现在假设你已经下了山，在你身后有一条漫长而艰苦的道路。你已经经过了几站和城镇，你遇到了另一个人，你问他你是否已经表现良好。 这个人永远无法告诉我们，如果没有和我们一起走过这条路，我们的表现是好是坏。即使这个人已经走了同样的道路，所有的因素都不一样，比如雨、雷暴、热、风等。 多年来一直在路上的人会知道它有多累，以及他们必须克服哪些障碍。只有通过上坡来获得高度。上坡总是令人筋疲力尽，我们可能会滑倒并再次滑下。这里至关重要的是不断前进。我们想要多快达到规定的高度完全取决于我们的雄心壮志。无论我们每天只走一步还是每天走十步，都只在持续时间中发挥作用。 尝试每天学习，即使只需要10分钟。 请看下面的数学示例，了解数字的差异： 365= 1.00 (1.00) 365= 37.7（1.01） 在这里，已经可以看到巨大的差异，它产生了多大的影响，即使我们每天只将性能提高1%。如果我们想记录我们的写作进度，回顾过去，看看我们已经走了多远，你可以创建两个列表。 列表 1在第一个列表中，你写下当前日期和你所知道的关于你想要的主题的所有知识，你所有的技能，估计等级为1-10。尽量使其尽可能详细。它越详细，差异就越清晰，以便您稍后看到。一旦您认为此列表已准备就绪，请将其放下或保存，以便即使在一年后您仍然可以访问它。 第2号清单第二个列表是连续编写的。这意味着，一旦您熟悉了某个主题，并且为自己学到了一些新东西，您就会将其添加到此列表中。尝试每天学习，即使只需要10分钟。如果您想更科学地做到这一点以获得更好的结果，请记录日历周。 我们将惊讶地看到我们在这段时间里取得的进展。最重要的是，我们清楚地看到，为什么除了我们自己之外，没有人能看出我们是否取得了良好的进展。 渗透学习的方式1 - 以工具为线索 如：Kali Linux，把里面的工具都弄懂 学习思路，以Metasploit为例：遍历每个子目录，除了Exploit里面还有什么每个工具怎么用 原理是什么，涉及哪些知识，能否改进优化，能否发展、组合出新的功能？ 2 - 以专家为线索 你的技术方向上有哪些专家，他们的邮箱、主页、社交网络账号是什么 他们在该方向上有哪些作品，发表过哪些演讲跟踪关注，一个一个地学。 如何提高效率?收集相关前人成果，避免无谓的重复劳动，能找到工具就不写代码，能用脚本语言写就不要用编译语言，把完美主义放在最终实现阶段，做好笔记并定期整理，遗忘会让所有的投入都白白浪费，多和同事交流，别人说一个工具的名字可能让你节约数小时，无论怎么提高效率，要成为专家，都需要大量的时间投入，作为人 ，成功都需要花费超乎想象的时间进行高强度的练习。观察一下你感兴趣的行业，研究一下别人的发展轨迹，你会逐渐发现，获取关键的技能和经验必须花费一定的时间。虽然具体情况会随着行业而变化，也会因人而异，但是它们都会让你认识到为了前进必须付出。你对需要学习的技能了解得越多，就越能为职业生涯做最佳决策，从而将你获得长期成功的可能性最大化。 努力仅有天赋是不够的，无论你拥有多高的智商或天赋，成功都需要花费超乎想象的时间进行高强度的练习。观察一下你感兴趣的行业，研究一下别人的发展轨迹，你会逐渐发现，获取关键的技能和经验必须花费一定的时间。虽然具体情况会随着行业而变化，也会因人而异，但是它们都会让你认识到为了前进必须付出。小野二郎被誉为全世界最好的寿司师傅之一，他要求手下的学徒在烹饪任何食物之前先花10年时间磨炼刀功。你对需要学习的技能了解得越多，就越能为职业生涯做最佳决策，从而将你获得长期成功的可能性最大化。 一个成熟的逆向工程师，需要具备 ’ 快速学习全新编程语言的能力，以及在分析过程中遇到问题时持之以恒的毅力与耐心。 如何阅读理解文章1.简化删减2.组合联结 黑客精神 勇于探索 独立思考 在解决问题中享受精神愉悦 自由与免费 创造者，重构自我，不断迭代","link":"/2022/06/25/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%9D%E8%80%83/"},{"title":"Fiddler抓包android","text":"官方文档https://www.telerik.com/fiddlerhttps://docs.telerik.com/fiddler/configure-fiddler/tasks/configureforandroid 1.配置Fiddler工具栏上面—Tools（工具）—Fiddler Options（选项）—Connections（连接）—勾选Allow remote computers to connect（允许远程计算机连接），重启Fiddler。 2.配置Android设备打开无线网络设置，进入你当前Wi-fi网络，修改网络。 找到代理设置，选择手动代理。 写入电脑上配置好的Fiddler服务器IP地址和端口 如： 12主机名:192.168.1.18端口:8888 验证此配置，请转到 **http://ipv4.fiddler:8888/**。Chrome 应该显示 Fiddler Echo Service 网页，流量应该出现在 Fiddler 中 3.解密HTTPSAndroid上面打开 1http://ipv4.fiddler:8888/ 然后在此页面中单击，FiddlerRoot certificate(FiddlerRoot证书)，安装证书。 安装前要在Android上设置下CA证书，每个手机不同，选择信任就行了。 Fiddler还要设置捕获HTTPS流量 Tools（工具）—Fiddler Options（选项）—HTTPS—Decrypt HTTPS traffic 这个时候，手机打开网页或APP，就能在电脑上的Fiddler看到流量了","link":"/2022/06/28/Fiddler/Fiddler%E6%8A%93%E5%8C%85android/"},{"title":"Docker","text":"Docker三步走1.生成映像 2.镜像生成容器 3.运行容器（docker run） 可以把映像成对象，对象生成方法等。 Docker 介绍 Docker就是一个虚拟机，里面的应用程序与主机相互隔离。 应用程序称为容器，容器无需依赖机上安装的内容。 可以共享容器，开发人员在本地编写代码，使用 Docker 容器与同事共享他们的工作。 可以在本地笔记本电脑、数据中心的物理机或虚拟机、云提供商或混合环境中运行。 Docker 体系结构 客户端&amp;服务器 Docker 客户端与 Docker 守护程序通信，后者负责构建、运行和分发 Docker 容器的繁重工作。 Docker 客户端和守护程序可以在同一系统上运行，也可以将 Docker 客户端连接到远程 Docker 守护程序。Docker 客户端和守护程序使用 REST API、UNIX 套接字或网络接口进行通信。另一个 Docker 客户端是 Docker Compose，它允许您使用由一组容器组成的应用程序。 Docker 守护程序 侦听 Docker API 请求并管理 Docker 对象：映像、容器、网络和卷。 守护程序还可以与其他守护程序通信以管理 Docker 服务。dockerd Docker 客户端Docker 用户与 Docker 交互的主要方式。客户端将命令发送到 ，后者会执行这些命令。该命令使用 Docker API。Docker 客户端可以与多个守护程序进行通信。docker``docker run``dockerd``docker Docker Desktop易于Mac 或 Windows 环境的安装应用程序，Docker Desktop 包括 Docker 守护程序 （）、Docker 客户端 （）、Docker Compose、Docker Content Trust、Kubernetes 和 Credential Helper。有关详细信息，请参阅 Docker Desktop。dockerd``docker Docker Hub 存储官方映像和私人的映像的地方 拉取映像命令1docker pull 推送映像命令1docker push Docker 对象映像映像是一个只读模板，其中包含有关创建 Docker 容器的说明。通常，一个映像基于另一个映像，并具有一些额外的自定义。例如，您可以构建一个基于该映像的映像，但会安装 Apache Web 服务器和应用程序，以及使应用程序运行所需的配置详细信息。ubuntu 您可以创建自己的映像，也可以只使用其他人创建并在注册表中发布的映像。若要生成自己的映像，请使用简单的语法创建一个 Dockerfile，用于定义创建映像并运行映像所需的步骤。Dockerfile 中的每条指令都会在映像中创建一个层。更改 Dockerfile 并重新生成映像时，只会重新生成已更改的层。与其他虚拟化技术相比，这是使映像如此轻巧、小巧和快速的部分原因。 容器容器是映像的可运行实例。您可以使用 Docker API 或 CLI 创建、启动、停止、移动或删除容器。可以将容器连接到一个或多个网络，将存储附加到该网络，甚至可以根据其当前状态创建新映像。 默认情况下，容器与其他容器及其主机相对隔离。您可以控制容器的网络、存储或其他底层子系统与其他容器或主机的隔离程度。 容器由其映像以及您在创建或启动容器时提供给它的任何配置选项定义。删除容器后，未存储在持久性存储中的任何对其状态所做的任何更改都将消失。 docker run 运行容器以交互方式附加到本地命令行会话，然后运行 。ubuntu``/bin/bash1$ docker run -i -t ubuntu /bin/bash 运行此命令时，将发生以下情况（假设您使用的是默认注册表配置）： 如果本地没有映像，Docker 会从配置的注册表中提取该映像，就像手动运行一样。ubuntu``docker pull ubuntu Docker 会创建一个新容器，就像手动运行命令一样。docker container create Docker 将读写文件系统分配给容器，作为其最后一层。这允许正在运行的容器在其本地文件系统中创建或修改文件和目录。 Docker 创建一个网络接口以将容器连接到默认网络，因为您没有指定任何网络选项。这包括为容器分配 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。 Docker 启动容器并执行 。由于容器以交互方式运行并附加到终端（由于 and 标志），因此您可以在将输出记录到终端时使用键盘提供输入。/bin/bash``-i``-t 键入以终止命令时，容器将停止但不会被删除。您可以再次启动它或删除它。exit``/bin/bash 开始教程命令提示符或 bash运行命令： 1$ docker run -d -p 80:80 docker/getting-started -d 在后台运行容器 -p 80:80 将主机端口 80 映射到容器中的端口 80 docker/getting-started 要使用镜像 简洁写法： 1$ docker run -dp 80:80 docker/getting-started Docker 仪表板快速查看计算机上运行的容器。Docker Dashboard 适用于 Mac 和 Windows。它使您可以快速访问容器日志，让您在容器内获得一个shell，并允许您轻松管理容器生命周期（停止，删除等）。 操作手册 Docker 桌面手册 映像映像包含容器的文件系统，它包含运行应用程序所需的一切 、配置、脚本、二进制文件等。 映像还包含其他配置，如环境变量、要运行的默认命令和其他元数据。 映像生成容器 容器 容器是计算机上的沙盒进程，与主机上其他进程隔离。 这种隔离利用了内核命名空间和 cgroups，这些功能已经在 Linux 中存在了很长时间。 是映像可运行实例。您以使用 DockerAPI 或 CLI 创建、启动、停止、移动或删除容器。 可以在本地机器、虚拟机上运行或部署到云中。 可移植（可以在任何操作系统上运行） 容器彼此隔离，并运行自己的软件、二进制文件和配置 示例使用一个在 Node.js 中运行的待办事项管理器，界面 获取应用程序先将待办事项管理器程序源代码获取到的计算机上。对于实际项目，通常会克隆存储库。 下载应用程序内容。您可以拉取整个项目，也可以将其下载为zip并将其解压缩出应用程序文件夹以开始使用。 提取后，使用您喜欢的代码编辑器打开项目，您应该看到 和 两个子目录 （ 和 ）。package.json``src``spec 生成应用的映像为了构建应用程序，需要使用 .Dockerfile 文本指令脚本，用于创建映像 介绍Dockerfile 创建Dockerfile，Dockerfile没有扩展名，该文件与包含以下内容的文件位于同一文件夹中。Dockerfile``package.json 12345678# syntax=docker/dockerfile:1FROM node:12-alpineRUN apk add --no-cache python2 g++ makeWORKDIR /appCOPY . .RUN yarn install --productionCMD [&quot;node&quot;, &quot;src/index.js&quot;]EXPOSE 3000 打开终端并转到包含的目录，使用命令生成映像 1$ docker build -t getting-started . 此命令使用 Dockerfile 生成新的映像。 下载映像后，在应用程序中复制并用于安装应用程序的依赖项。该指令指定从此映像启动容器时要运行的默认命令。yarn``CMD 最后，标志标记映像。只需将其视为最终映像的人类可读名称。由于命名了映像，因此可以在运行容器时引用该图像。-t getting-started 该命令的末尾 . (点) 指示 Docker 在当前目录中查找 。 启动应用容器现在有了一个映像，运行该应用程序。还记得前面的命令吗？docker run 运行刚刚创建映像的名称： 1$ docker run -dp 3000:3000 getting-started 几秒钟后，打开 Web 浏览器浏览 http://localhost:3000。应该会看到应用程序 您可以将项目标记为完整并删除项目。前端已成功将项目存储在后端。 管理容器快速查看 Docker 仪表板，会看到两个容器正在运行","link":"/2022/06/22/docker/docker/"},{"title":"Hexo添加分类和标签","text":"1. 创建“分类”选项生成“分类”页并添加tpye属性,进入博客目录。执行命令下方命令 1$ hexo new page categories categories文件夹下会有index.md这个文件，打开后默认内容是这样的： 1234---title: categoriesdate: 2019-04-22 14:47:40--- 添加type: “categories”到内容中，添加后是这样的： 12345---title: 分类date: 2019-04-24 15:30:30type: categories--- 保存并关闭文件。 给文章添加“categories”属性 打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。 12345---title: Hexo 添加分类及标签date: 2017-05-26 12:12:57categories: Hexo--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 2. 创建“标签”选项生成“标签”页并添加tpye属性 1$ hexo new page tags 在tags文件夹下，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 标签date: 2019-04-22 14:22:08--- 添加type: “tags”到内容中，添加后是这样的： 12345---title: 标签date: 2019-04-24 15:40:24type: tags--- 保存并关闭文件。 给文章添加“tags”属性,打开需要添加标签的文章，为其添加tags属性。 12345678---title: Hexo 添加分类及标签date: 2019-04-24 15:40:24categories: - Hexotags: - 博客---","link":"/2022/06/24/hexo/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE/"},{"title":"【Hexo】Hexo部署到GitHub","text":"需要下载的 Node.js hexo git 安装hexoNode.js和git基本上都是下一步下一步解决。当安装完git和Node.js后，开始安装hexo hexo安装，新建一个文件夹（存放hexo网站内容的地方），在此文件夹内打开Git Bash，右键里面就有。 打开后，输入安装命令： 1npm install hexo-cli -g 安装完成，查看hexo版本，检测是否安装成功 1hexo -v 初始化Hexo在上面建立的文件夹内，同样在git bash内输入命令 1hexo init 接着安装 1npm install 网站配置信息_config.yml文件网站标题，使用主题名都在这个文件中，详细参考官方文档。 themes文件夹存放主题文件的地方 部署到Github回到 hexo文件夹，Git Bash输入命令 1npm install hexo-deployer-git --save 以上是安装部署所需要的组件 修改_config.yml_config.yml是根本中的，在下面增加以下内容，repo是你自己的github pages地址 1234deploy: type: git repo: https://github.com/username/username.github.io.git branch: master type:部署模式 repo:你的地址 branch:选择分支，预设为master 部署输入命令，开始部署 1hexo deploy 每次修改的操作12345hexo cl //清除之前的静态网站hexo g //重新生成静态页面hexo d // 部署到GitHub","link":"/2022/06/23/hexo/%E3%80%90hexo%E3%80%91hexo%E9%83%A8%E7%BD%B2%E5%88%B0github/"},{"title":"【反汇编】编译前言","text":"debug版与Release版对反汇编的影响分别将运算表达式的结果直接计算出来赋值结果等都计算了出来 debug版提供的反汇编更为详细Release版本将汇编代码优化的更精简，执行速度更快 全局变量与局部变量在内存中的情况全局变量在内存中地址不变：编译的时候已经确定内存地址和宽度，变量名就是内存地址的别名，如果不重写编译，全局变量的内存地址不变，外挂中找基址，就是找全局变量 局部变量是函数内部的变量，函数没有执行，局部变量就不存在，局部变量的内存是在堆栈中分配的，程序执行时才分配，无法预知程序何时执行，也无法确定局部变量的内存地址。 全局变量全局变量放在内存区中，一直存在，通常位于一个固定地址处。当程序需要访问全局变量时，会直接对内存寻址。示例： 1mov eax,dword ptr[4084C0h] ;调用全局变量,4084C0h为全局变量的地址 数组访问数组的方式： 1mov edi,dword ptr[eax+407030];407030为a[]数组的地址 寻址方式： 1mov eax,[407030h + eax];基址+偏移 文本字符串寻址 1mov eax,[401000h];直接寻址 1mov eax,[ecx];寄存器间接寻址 1lea eax,[401000h] ;lea意思是装入有效地址，它的操作数是地址。和mov类似 lea也可以来计算常量和lea eax,[eax+8] 等于 add eax,8","link":"/2022/06/23/%E5%8F%8D%E6%B1%87%E7%BC%96/%E3%80%90%E5%8F%8D%E6%B1%87%E7%BC%96%E3%80%910x1%20%E7%BC%96%E8%AF%91%E5%89%8D%E8%A8%80/"},{"title":"【反汇编】for循环","text":"C++源码1234for(int i=0;i&lt;=50;i++){cout&lt;&lt;&quot;wo shi xun huan&quot;;} 反汇编123456mov 【寄存器】,【循环次数】 循环体代码1.... 循环体代码2.... 循环体代码3....sub esi,1 【esi里面的值减去1，减去循环次数】jne 【跳回循环体首部地址】当循环次数减到等于0，将不执行循环体，将会跳出循环。","link":"/2022/06/23/%E5%8F%8D%E6%B1%87%E7%BC%96/%E3%80%90%E5%8F%8D%E6%B1%87%E7%BC%96%E3%80%910x2%20for%E5%BE%AA%E7%8E%AF/"},{"title":"【反汇编】if","text":"C代码 12345678910int a = 0;cin &gt;&gt; a;if (a == 10){cout &lt;&lt; &quot;a=10&quot;;}else{cout &lt;&lt; &quot;输入的不等于10&quot;;} 反汇编后的汇编代码 1234cmp dword [esp],值 //比较两个值cmp 【程序代码的条件】,【现在状态的条件】je 地址 //比较后控制标志位寄存器，标志位寄存器影响je是否跳转,je的跳转与不跳转，分别是执行到代码区域if和elsejmp 地址//否则直接跳到","link":"/2022/06/23/%E5%8F%8D%E6%B1%87%E7%BC%96/%E3%80%90%E5%8F%8D%E6%B1%87%E7%BC%96%E3%80%910x3%20if/"},{"title":"","text":"123456789101112131415switch(条件){case 1: cout&lt;&lt; break;case 2: cout&lt;&lt; break;case 3: cout&lt;&lt; break;default: cout&lt;&lt; break;} 反汇编 12345678910switch(条件) 对应以下：cmp 【条件】【现有条件】 case 1:je 【地址】cmp 【条件】【现有条件】 case 2:je 【地址】cmp 【条件】【现有条件】 case 3:je 【地址】","link":"/2022/05/02/%E5%8F%8D%E6%B1%87%E7%BC%96/%E3%80%90%E5%8F%8D%E6%B1%87%E7%BC%96%E3%80%910x5%20switch%E8%AF%AD%E5%8F%A5/"},{"title":"","text":"代码 1char a[] = &quot;test&quot; 反汇编 1234mov eax,dword ptr ds:[339B30]mov dword ptr ss:[ebp-10],eaxmov cl,byte ptr ds:[339B34]mov byte ptr ss:[ebp-C],cl dword 代表双字 就是4个字节 ptr pointer缩写 就是指针 []里的数据是一个地址值，这个地址指向一个双字型数据 如：mov eax,dword ptr ds:[339B30] 把内存地址339B30里面的数据赋给eax","link":"/2022/05/04/%E5%8F%8D%E6%B1%87%E7%BC%96/%E3%80%90%E5%8F%8D%E6%B1%87%E7%BC%96%E3%80%910x6%20%E6%95%B0%E7%BB%84/"},{"title":"【反汇编】识别运算符","text":"减法汇编是:sub计算机只会做加法，通过补码转换成减法。源码： 1234567891011int a = argc; int b = 0;scanf(&quot;%d&quot;,&amp;b);a = a - 100; //mov eax,dword ptr[ebp-4] 取变量a到eax //sub eax,64h 使用减法指令sub,对eax执行减100操作 //mov dword ptr[ebp-4],eax 将结果给变量aa = a + b - b;//mov ecx,dword ptr[ebp-4] //add ecx,5 //sub ecx,dword ptr[ebp-8] //mov dword ptr[ebp-4],ecxprintf(&quot;a = %d\\r\\n&quot;,a); 乘法乘法对应的汇编指令有两种有符号：imul无符号：mul由于乘法执行周期长，在编译过程中，编译器会将乘法转换成加法。或使用移位等周期较短的指令。当它们都不可转换时，才会使用乘法指令直接使用乘法指令imulprintf(“%d”,nVarOne15); //mov edx,dword ptr[ebp-4] //imul edx,edx,0Fh 直接使用乘法指令imul ,h代表十六进制printf(“%d”,ab); //mov ecx,dword ptr[ebp-4] //imul ecx,dword ptr[ebp-8]使用左移运算符代替乘法运算printf(“%d”,nVarOne16); //mov eax,dword ptr[ebp-4] //shl eax,4编译期间计算出22结果，将表达式转换为常量值printf(“22 = %d”,22); //push 4 //push offset string “22=%d” //call printf(0040b750) //add esp,8利用lea指令完成组合运算printf(“nVarTwo4+5=%d”,nVarTwo4+5); //mov ecx,dword ptr[ebp-8] //lea edx,[ecx4+5] 除法对应的汇编指令也是两种有符号：idiv无符号：div算数结果溢出int类型的数据0XFFFFFFF加2得到的结果，将会超出int类型的存储范围。超出的为溢出数据，溢出数据无法被保存，会丢失。对有符号数，原数据为一个负数，溢出后，表示符号的被进位，由1变成0，这时负数也成为了整数。自增和自减++–int a = argc;int b = argc;b = 5+(a++); //mov edx,dword ptr[ebp-4] 取出变量a保存在edx中 //add edx,5 变量a+5 //mov dword ptr[ebp-8],edx 将edx=5放到变量b //mov eax,dword ptr[ebp-4] 将a变量放到eax //add eax,1 将a变量+1 //mov dword ptr[ebp-4],eax 将值给变量ab = 5+(++a);dword ptr[ebp-4] = 变量 三目运算符return argc == 5 ? 5:6; //参数argc如果等于5，那么运行5，否则运行6 反汇编xor eax,eax //清空eaxcmp dword ptr[ebp+8],5 //将5和变量进行对比判断setne al //检查ZF标记位，当ZF==1，则赋值al为0，反之赋值为1add eax,5 //若上面al=0那么这里就是add eax,5，若上面al = 1 那么这里是add eax,6 位运算二进制的运算叫位运算&lt;&lt;：左移运算，最高位左移到CF中，最低位补0 ：右移运算，最高位不变，最低位右移到CF中|：或运算，两个数相同位上，只要有一个为1，结果等于1&amp;：位与运算，两个数同时为1时，结果才等于1^：异或运算，两个值相同时，等于0，不相同时等于1~：取反运算，将数取反，1那么就等于0，0就等于1.","link":"/2022/06/23/%E5%8F%8D%E6%B1%87%E7%BC%96/%E3%80%90%E5%8F%8D%E6%B1%87%E7%BC%96%E3%80%910x4%20%E8%AF%86%E5%88%AB%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"","text":"","link":"/2022/05/02/%E5%8F%8D%E6%B1%87%E7%BC%96/%E3%80%90%E5%8F%8D%E6%B1%87%E7%BC%96%E3%80%91do%20while/"},{"title":"Information Gathering（信息收集）","text":"0x1 域名信息域名信息 子域名挖掘 layer subdomain 子域名扫描工具：https://github.com/bit4woo/teemo 域名信息收集 wydomain IP枚举 http://www.asnlookup.com 该工具利用 ASN 查找特定组织拥有的 IP 地址（IPv4 和 IPv6）以进行侦察。 从 favicon 图标开始并使用 Shodan 查找真实 IP https://github.com/pielco11/fav-up CDN绕过 超级ping（站长工具、很多接口都有） 借助全国各地或世界各地服务器对一个网站进行ping解析，通过解析的IP地址的情况来进行判 断是否存在cdn，如果IP不一样说明CDN存在，如果IP都一样那么说明CDN不存在 https://www.fujieace.com/penetration-test/cdn-find-ip.html 0x2 目录信息目录信息 网站目录扫描 whatweb dirsearch httpsgithub.commaurosoriadirsearch DirBuster 敏感文件 robots.txt 源码备份文件泄露 sitemap.xml 御剑 httpsgithub.comring04hdirfuzz search Hack httpswww.uedbox.comshdb httpswww.uedbox.compost54776 谷歌黑客 site域名 ，搜索域名 intext正文中存在关键字的网页 intitle搜索网页标题关键字（如管理登录） info基本信息 inurlurl关键字 filetype后缀文件类型 cacheurl 缓存搜索 黑暗引擎 shodan zoomeye 针对网络设备的搜索引擎 cms网站指纹扫描 nsonaniya2010SubDomainizer bugscaner cmsmap whatweb 御剑指纹识别 云悉 JS扫描 JSFind 快速提取网站中js文件的URL，子域名的工具 https://github.com/Threezh1/JSFinder JS信息泄露 JS里包含敏感信息 0x3 端口信息端口信息（ports） Nmap 从Nmap扫描中提取实时IP nmap 10.1.1.1 –open -oG scan-results; cat scan-results | grep “/open” | cut -d “ “ -f 2 &gt; exposed-services-ips masscan 0x4 已知漏洞扫描工具 Nessus Nikto Appscan W3af Xray openvas w9scan bugscan python 漏洞验证框架 查看服务器三方软件漏洞工具 Netsparker四叶草的漏洞扫描器 3xp10itpentestbox 整合了kali中大部分的安全工具，Windows平台上的神器溯光 https://www.trackray.cn/ https://github.com/iSafeBlue/TrackRaypocsuite 知道创宇的POC漏洞测试框架一体化工具推荐：fuzzscannerxunfeng https://github.com/ysrc/xunfengFuxi Scanner一款聚合了很多功能的综合扫描器 https://github.com/jeffzh3ng/Fuxi-ScannerSQLiScannerGourdScanV2 https://github.com/ysrc/GourdScanV2exploit searchsploit exploitdb 扫描waf​ Wafw000f脚本判断是否有waf移动端​ AppInfoScanner​ 对APP中进行关键资产信息收集，比如URL地址、IP地址、关键字等信息的采集等​ 下载​ https://github.com/kelvinBen/AppInfoScanner/releases/latest​ 2.安装依赖库​ cd AppInfoScannerpython3 -m pip install -r requirements.txt​ 使用​ python3 app.py android -i &lt;您的APK文件或DEX文件或APK下载Url或保存文件目录&gt;email​ 子主题 1api​ postman​ graphqlmapssl​ sslscan​ sslhopper业务监控​ python脚本监控​ 浏览器插件​ 网页哨兵​ Distill Web Monitor​ github监控​ 监控子域名​ Subler","link":"/2022/06/23/Web%20vulnerability/0x0%20Information%20Gathering%EF%BC%88%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%89/Information%20Gathering%EF%BC%88%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%89/"},{"title":"Broken Access Control（越权访问）","text":"访问控制安全模型编程访问控制 用户权限存储在数据库或类似数据库中 自由访问控制 （DAC） 对资源或函数的访问将基于用户或指定的用户组进行限制。 资源或函数的所有者能够向用户分配或委派访问权限。 具有为单个资源或函数和用户定义的访问权限。因此，模型的设计和管理可能会变得非常复杂。强制访问控制 （MAC） 强制访问控制是一种集中控制的访问控制系统，其中主体对某些对象（文件或其他资源）的访问受到限制。 与 DAC 不同，资源的用户和所有者无法委派或修改其资源的访问权限。 这种模式通常与基于军事许可的系统相关联。基于角色的访问控制 （RBAC） 定义访问权限的角色。将用户分配到单个或多个角色。 例如，采购职员可能被定义为对采购分类帐功能和资源的子集具有访问权限的角色。当员工离开或加入组织时，访问控制管理将简化为定义或撤销采购员角色的成员身份。 当有足够角色来正确调用访问控制，但数量不大以至于使模型过于复杂且难以管理时，RBAC 最有效。 垂直访问控制 管理员 访问管理页面 能够修改或删除帐户 普通用户 访问普通用户页面 案例 直接访问管理员页面的URL 攻击者跳到管理页面进行访问 https://insecure-website.com/admin 管理页面URL位置泄露 robots.txt https://insecure-website.com/robots.txt 暴力破解敏感功能的位置 JS中暴露管理URL var isAdmin = false; if (isAdmin) { ... var adminPanelTag = document.createElement('a'); adminPanelTag.setAttribute('https://insecure-website.com/administrator-panel-yb556'); adminPanelTag.innerText = 'Admin panel'; ... } 12345678910&lt;script&gt;var isAdmin = false;if (isAdmin) { ... var adminPanelTag = document.createElement('a'); adminPanelTag.setAttribute('https://insecure-website.com/administrator-panel-yb556'); adminPanelTag.innerText = 'Admin panel'; ...}&lt;/script&gt; 水平访问控制 专门用户，访问专门资源 不同用户访问不相同类型的资源子集 如银行应用程序将允许用户从自己的帐户查看交易和付款，但不允许任何其他用户的帐户。 横向权限提升 当用户能够访问属于另一个用户的资源（而不是他们自己的该类型的资源）时，就会出现水平权限提升。普通操作，员工只能访问自己就业和工资单记录，但它通过URL或提交数据的方式，访问了其他员工记录，那么这就是横向权限提升。 用户通常可以使用URL 访问自己的帐户页面： https://insecure-website.com/myaccount?id=123 攻击者将参数值修改为其他用户的参数值，攻击者可能会访问其他用户的帐户页面，其中包含关联的数据和功能 上下文相关的访问控制 根据应用程序状态或用户 与应用程序的交互来限制对功能和资源的访问。 上下文相关的访问控制可防止用户以错误的顺序执行操作。 例如，零售网站可能会阻止用户在付款后修改购物车的内容。 产生的原因 隐藏管理员url链接 由请求参数控制用户权限 目录遍历（文件路径遍历） 攻击者可以利用此漏洞读取应用程序的服务器上的任意文件（可能包括，程序代码、数据、敏感数据等）在某些情况下，攻击者能够写入服务器上的任意文件，并最终完全控制服务器。 URL 采用一个参数并返回指定文件的内容。映像文件本身存储在磁盘上的位置 。应用程序会将请求的文件名追加到此基目录，并使用文件系统 API 读取文件的内容。 攻击者构造URL，检索服务器任意文件 https://insecure-website.com/loadImage?filename=../../../etc/passwd 该序列在文件路径中有效，意味着在目录结构中提升一个级别。三个连续的序列从文件系统根目录向上递进，因此实际读取的文件是：../..//var/www/images/ /etc/passwd 在基于 Unix 的操作系统上，这是一个标准文件，其中包含在服务器上注册的用户的详细信息。 编码目录遍历 ..%252f..%252f..%252fetc/passwd 截断后后缀名，遍历目录../../../etc/passwd%00 .png 防止目录遍历攻击 避免将用户的输入完全传递给文件系统 API 重写许多执行此操作的应用程序函数，以更安全的方式提供相同的行为 结合两层防御来防止攻击： 验证用户输入。与白名单进行比较。验证输入仅包含允许的内容，如纯字母数字字符。验证提供的输入后，应用程序将输入追加到基目录，并使用平台文件系统 API 规范化路径 下面是一些简单的 Java 代码示例，用于用户输入验证文件的规范路径：File file = new File(BASE_DIRECTORY, userInput);if (file.getCanonicalPath().startsWith(BASE_DIRECTORY)) { // process file} 基于参数的访问控制方法 某些应用程序在登录时确定用户的访问权限或角色，然后将此信息存储在用户可控制的位置，如隐藏字段、Cookie 或预设的查询字符串参数。应用程序根据提交的值做出后续的访问控制决策。例如：https://insecure-website.com/login/home.jsp?admin=truehttps://insecure-website.com/login/home.jsp?role=1 这种方法从根本上是不安全的，因为用户可以简单地修改值并访问他们无权访问的功能，例如管理功能。 由于平台配置错误导致的访问控制中断 某些应用程序通过根据用户的角色限制对特定 URL 和 HTTP 方法的访问，在平台层强制实施访问控制。例如应用程序配置如下规则：DENY: POST, /admin/deleteUser, managers此规则拒绝管理员组中的用户访问 URL在这种情况下，各种事情可能会出错，导致访问控制绕过。POST/admin/deleteUser某些应用程序框架支持各种非标准 HTTP 标头，这些标头可用于覆盖原始请求中的 URL例如如网站使用严格的前端控件来限制URL 的访问，但应用程序允许通过请求标头覆盖 URL使用如下请求绕过访问控制：X-Original-URLX-Rewrite-URLPOST / HTTP/1.1X-Original-URL: /admin/deleteUser 防范措施 1、前后端同时对用户输入信息进行校验，双重验证机制2、执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限3、特别敏感操作可以让用户再次输入密码或其他的验证信息。4、可以从用户的加密认证 cookie 中获取当前用户 id，防止攻击者对其修改。或在session、cookie 中加入不可预测、不可猜解的 user 信息。5、直接对象引用的加密资源ID，防止攻击者枚举ID，敏感数据特殊化处理6、永远不要相信来自用户的输入，对于可控参数进行严格的检查与过滤 类型 1. 通过隐藏URL实现控制访问有些程序的管理员的管理页面只有管理员才显示，普通用户看不到，利用 URL实现访问控制，但 URL泄露或被恶意攻击者猜到后，这会导致越权攻击。2. 直接对象引用这种通过修改一下参数就可以产生水平越权，例如查看用户信息页面 URL 后加上自己的 id 便可查看，当修改为他人的 ID 号时会返回他人的信息，便产生了水平越权。3. 多阶段功能例如修改密码，可能第一步是验证用户身份信息，号码验证码类的。当验证成功后，跳到第二步，输入新密码，很多程序会在这一步不再验证用户身份，导致攻击者抓包直接修改参数值，导致可修改任意用户密码。越权访问（Broken Access Control，简称BAC）是Web应用程序中一种常见的漏洞，由于其存在范围广、危害大，被OWASP列为Web应用十大安全隐患的第二名。一旦权限验证不充分，就易致越权漏洞。一个Web程序功能正常流程登录提交请求验证权限数据库查询返回结果如果验证权限不足，便会导致越权。常见的程序都会认为通过登录后即可验证用户的身份，从而不会做下一步验证，最后导致越权。 静态文件很多网站的下载，例如 pdf、word、xls 等，只有付费用户可下载，当这些文件URL地址泄露后，通过URL可直接下载，如果知道URL命名规则，则会便利服务器的收费文档进行批量下载。 平台配置错误一些程序会通过控件来限制用户的访问，如后台地址，普通用户不属于管理员组，则不能访问。但当配置平台或配置控件错误时，就会出现越权访问。","link":"/2022/06/24/Web%20vulnerability/0x1%20Server%20vulnerability%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%BC%8F%E6%B4%9E)/Broken%20Access%20Control%EF%BC%88%E8%B6%8A%E6%9D%83%E8%AE%BF%E9%97%AE%EF%BC%89/"},{"title":"Client-side URL Redirect（URL重定向）","text":"漏洞产生的原因未对变量（传入跳转url）检查和限制 易出现的地方 用户登录、统一身份认证处，认证完后会跳转 用户分享、收藏内容过后，会跳转 跨站点认证、授权后，会跳转 站内点击其它网址链接时，会跳转 修改参数中合法的URL为非法URL，然后查看是否能正常跳转 实现方式1.META标签内跳转 1&lt;meta http=equiv=&quot;Refresh&quot; content=&quot;5; url=&lt;?php echo $url?&gt; 2.javascript跳转 12var site = getQueryString(&quot;site&quot;);//获取用户请求链接window.location.href=site;//跳转到链接地址 3.header跳转 1www.a.com/url.php?url=https://www.baidu.com 加密url，短地址 1http://qt.qq.com/safecheck.html?flag=1&amp;url=http://t.cn/RVTatrd 漏洞示例 1234var redir = location.hash.substring(1);if (redir) { window.location='http://'+decodeURIComponent(redir);}","link":"/2022/06/23/Web%20vulnerability/0x2%20Client%20vulnerability%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%BC%8F%E6%B4%9E%EF%BC%89/Client-side%20URL%20Redirect%EF%BC%88URL%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%89/"},{"title":"Cross Site Request Forgery（CSRF） 跨站点请求伪造","text":"执行构造好的URL，如http://x.com/del.php?id=1 可以删除ID为1的账号，但只有管理员有这个删除权限，恰巧这个网站有CSRF漏洞，攻击者在其他网页插入了一段代码：＜imgsrc=”http://x.com/del.php?id=1”＞将此URL发给了管理员，管理员的浏览器浏览此页面，发送请求后，会将id为1的账号删除，整个攻击流程攻击完毕 黑盒打开几个有非静态操作的页面，抓包看看有没有token，如果没有token的话，再直接请求这个页面，不带referer。如果返回的数据还是一样的话，那说明很有可能有CSRF漏洞了 白盒看几个功能核心文件里面有没有验证token和referer相关的代码，或者直接搜”token”这个关键字。 因为是用户浏览器发送的请求，用户浏览器是可信的，并包含了Cookie，所以服务器通过了验证。 浏览器Cookie策略Session Cookie（临时Cookie）没有指定Expire时间，关闭浏览器后，Session Cookie就失效了 Third-party Cookie（本地Cookie)服务器在Set-Cookie时指定了Expire时间，只有到了Expire时间后Cookie才会失效，这种Cookie会保存在本地。","link":"/2022/06/24/Web%20vulnerability/0x2%20Client%20vulnerability%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%BC%8F%E6%B4%9E%EF%BC%89/Cross%20Site%20Request%20Forgery%EF%BC%88CSRF%EF%BC%89%20%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"},{"title":"Clickjacking","text":"","link":"/2022/06/28/Clickjacking/"}],"tags":[{"name":"Vulnerabilityg","slug":"Vulnerabilityg","link":"/tags/Vulnerabilityg/"},{"name":"ios","slug":"ios","link":"/tags/ios/"},{"name":"Fiddler","slug":"Fiddler","link":"/tags/Fiddler/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"web safe","slug":"web-safe","link":"/tags/web-safe/"}],"categories":[{"name":"思考与人生","slug":"思考与人生","link":"/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E4%BA%BA%E7%94%9F/"},{"name":"Fiddler","slug":"Fiddler","link":"/categories/Fiddler/"},{"name":"android","slug":"android","link":"/categories/android/"},{"name":"运行环境","slug":"运行环境","link":"/categories/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"反汇编","slug":"反汇编","link":"/categories/%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"name":"Information Gathering","slug":"Information-Gathering","link":"/categories/Information-Gathering/"},{"name":"Server vulnerability","slug":"Server-vulnerability","link":"/categories/Server-vulnerability/"},{"name":"Client vulnerability","slug":"Client-vulnerability","link":"/categories/Client-vulnerability/"}]}